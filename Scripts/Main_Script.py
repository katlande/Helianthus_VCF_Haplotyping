#Kathryn Lande -- October 2019
#Inversion haplotyping from diagnostic SNP list
#Python2.7

#Set up
#import sys

#This script is made to be used with the diagnostic SNP lists generated by Greg Owens (https://github.com/owensgl/wild_gwas_2018/tree/master/MDS_outliers/Ha412HO) -- files ending in ".pcasites.txt.gz", and a standard VCF.
#This script is untested for an Ha412 input. It is intended for use with HanXRQ SNPs, but I have added an option to use Ha412 too.

### SECTION 1: SET UP ###
### This section sets up the rest of the script by defining the output file name, and defining some global object names ###


if iterations_script == "on":
    print "Using iterations..."
else:#only prompt the user to input the reference genome if not using the iterations script (so they don't have to enter it for each iteration)
    rg = input("Please indicate whether you are using the Ha412(0) or HanXRQ(1) reference genome (0/1): ")
    if rg ==1:#the two reference genome loci are contained in different columns of the input text file. This sets a global parameter based on the reference genome the user is working in:
        Ref_Genome_Chr_Col = 2#XRQ columns
        Ref_Genome_Pos_Col = 3
    elif rg ==0:
        Ref_Genome_Chr_Col = 0#412 columns
        Ref_Genome_Pos_Col = 1
    else:
        print "Fatal Error:", rg, "is not a recognized Option. Please try again."#if the inout is faulty, the user will be told and ejected fromt he code.
        exit()

Ref_Col = 3#If the reference allele column in the VCF is NOT the fourth column from the left, set this number to (1-column number). In standard VCFs this should be consistent.
Alt_Col = 4#If the alternate allele column in the VCF is NOT the fifth column from the left, set this number to (1-column number). In standard VCFs this should be consistent.

if iterations_script == "on":#for some reason this script only works when I used a different object name for the iterations input and the non-iterations input. Not sure why. Had to make a deliniation here and at line 68.
    Output_Name = input_diagnostic_site_list[:-4]#Use the input text file name to make the output name by removing the .txt extension
    Output_Name += "_HAPLOTYPES.txt"#and adding _HAPLOTYPES.txt to the end.
    Output_file_name = Output_Name
else:
    Output_Name = input_diagnostic_site_file[:-4]#same but with a different DS file label
    Output_Name += "_HAPLOTYPES.txt"
    Output_file_name = Output_Name


### SECTION 2: Input the inout files, discard extraneous information to speed up the program, and reformat the input information ###

#Open VCF and split lines into separate objects in a list:
InputVCF = open(input_VCF, 'r')
linelist = []

for string in InputVCF:#different VCFs have different end line characters for some reason? This loop checks which the vcf has and parses the lines accordingly
    if "\n" in string:
        linelist.append(string)
    elif "\r" in string:
        linelist = string.split("\r")
    elif "\r\n" in string:
        linelist = string.split("\r\n")
    else:
        print "Fatal Error: Endline Character not recognized."#I'm not sure why this would ever happen but I put it in just in case
        exit()
InputVCF.close()

VCF_list = []
for x in linelist: #For each line in the VCF, only keep lines that DO NOT start with "##" There are MANY lines of metadata that start this way and trimming them out will speed up the code later.
    if "##" not in x:
        temp = x.split("\t")#Separate objects in each line into a list where indices start after each \t
        VCF_list.append(temp)

#Open Diagnostic SNPS:
Diagnostic_list = []
if iterations_script == "on":#if using iterations,
    InputDS = open(input_diagnostic_site_list, 'r')#open a file that represents a single line of the iterations list file
    for row in InputDS:#for each row of the DS file
        temp = row.strip()#remove endline character into a temporary object
        temp = row.split("\t")#split the rows into lists at each \t
        Diagnostic_list.append(temp)#and append each row list into a bigger list.
    InputDS.close()
else:#if not using iterations, do the same thing but use the DS site file directly
    InputDS = open(input_diagnostic_site_file, 'r')
    for row in InputDS:
        temp = row.strip()
        temp = row.split("\t")
        Diagnostic_list.append(temp)
    InputDS.close()


###SECTION 3: Make a look up function to pull out only the diagnostic sites contained within the VCF. This will save memory later on:###

def signif_sites(vcflist,DSlist,DSindex,signifDSlist):#pull out significant sites with this function. Input the VCF line list, the Diagnostic site line list, and a variable that acts as the line of the Diagnostic list thats being queried. "signifDSlist" is an empty list to fill with only diagnostic sites that have a match.
    signiflist = []#empty list to append significant lines of the VCF into 
    for x in range (0, (len(vcflist))):#for all sites in the VCF list,
        if vcflist[x][0] == DSlist[DSindex][Ref_Genome_Chr_Col] and vcflist[x][1] == DSlist[DSindex][Ref_Genome_Pos_Col]:#if the chr and pos indicies match between the vcf list and the DS list
            temp = list(vcflist[x])#make a temporary object from the significant line in the vcf list
            tempDS = DSlist[DSindex]
            tempDS = [x.replace('\n', '') for x in tempDS]#strip \n from end of line
            signiflist.append(temp)#append the temporary object into the significant VCF line list
            signifDSlist.append(tempDS)
    return signiflist#return the list
#This function will ONLY check a single line of the diagnostic site list!!!!!!

c = 0#for a while loop counter
significant_VCF_list = []#empty lists for ouput..
signifDSlist = []
while c < len(Diagnostic_list):#set up a loop that runs the look up functoin for ALL lines of the diagnostic site list
    temp = signif_sites(VCF_list,Diagnostic_list,c,signifDSlist)
    if len(temp) > 0:#if there was a hit for the DS,
        significant_VCF_list.extend(temp)#append the matching VCF line into a new list
    c += 1#repeat for all lines of the DS list

sites_signif = len(significant_VCF_list)#total lines pulled from the vcf
sites_total = len(VCF_list)#total lines in the vcf
NA_count = (sites_total - sites_signif)#number of DS sites with no match in the VCF
Percent_Kept = (1-(1.0*NA_count)/(1.0*sites_total))*100#percent of the DS list with hits


###Section3.5: a few lines to make the terminal output pretty:###

pk = str(Percent_Kept)#These next few lines are all for aesthetics...
st = str(sites_total)
nc = str(NA_count)
space = "               "
t = len(st)#These lines make the spaces in the output equal to the (maximum number of spaces - the length of each line's text), so the endline hashmarks are always in line with each other.
n = len(nc)
s = space[t:]#aesthetics done
ns = space[n:]

print "\n###################################################\n#                                                 #"
print "#      sites in VCF:", sites_total, s, "            #"
print "#     ", pk[:4], "% of Diagnostic Sites match VCF       #\n#      Non-Diagnostic VCF Sites:", nc, ns, "#"
print "#                                                 #\n###################################################\n"
#this output will tell you how many lines in the VCF were checked, and how many matched diagnostic sites. If it's 0, you can know there's a problem.


###Section 4: Reformatting the VCF so it can be directly matched to the DS input information:###

#Make a list of sample names:
headers = VCF_list[0]
headers = headers[9:]
headers = [x.replace('\n', '') for x in headers]#strip \n from end of line

#Replace numerical SNP indicators with nucleotides
#Write a function that replaces nucleotides in a SINGLE LINE of the significant VCF:
def replace_nuc(vcf,pos,sample_list):#input a vcf, a line #, and a sample names list
    temp_vcf = vcf#make a temportary object
    for x in range(0, (len(sample_list))):#for all indices in the number of samples
        i = (x + 9)
        index = vcf[pos][i]#the index is the vcf input line, starting at position 9 (where sample info begins)
        index_temp = str(index)#make a temporary string out of the index line
        if "0/0" in index_temp:#if the sample index contains 0/0
            temp_vcf[pos][i] = vcf[pos][Ref_Col]#make the index in the temporary vcf the refernce nucleotide
        elif "0/1" in index_temp or "1/0" in index_temp:#for het
            temp_vcf[pos][i] = "HET"#make the index het
        elif "1/1" in index_temp:
            temp_vcf[pos][i] = vcf[pos][Alt_Col]#for 1/1 make the index the alt nucleotide
        else:
            temp_vcf[pos][i] = "NA"#if the index doesn't contain any then make the site "NA" (SNP calling errors...)
    return temp_vcf#return the temporary vcf line

#Iterate the replace_nuc function over all lines of the singifcant site VCF:
d = 0#counter for while loop
while d < len(significant_VCF_list):#for all lines in the of the significant VCF list
    replace_nuc(significant_VCF_list,d,headers)#replace numbers with nucleotides
    d += 1
#print significant_VCF_list#sanity check


###Section 5: The section where all the magic happens! Creating the output file by matching diagnostic sites and VCF sites:###

#Make a list of output table headers 
output_headers = ["Sample Name", "INV0 Count", "INV0 Probability", "INV1 Count", "Inv1 Probability", "HET Count", "HET Probability", "NA Count", "Total Sites","Most Likely Haplotype"]

#Write a function that, for each sample, counts the diagnosis for each variant site and outputs the probability of each haplotype:

#simple product function I need to use within the haplotype_sample() function (not mine - from striver_79 @ Codeforces):
def product(prodlist):
    r = 1.0
    for x in prodlist: 
        r = r * x  
    return r  

#Identify the haplotype of each sample. Brace yourself this function is a BIG BOY:
def haplotype_sample(signifDSlist,significant_VCF_list,sample):#input significant DS list, significant VCF sites list, and the "sample" (column of the VCF of the sample of interest)
    #Make 3 empty lists, 4 empty objects:
    # = Inv0_p, Inv1_p, Het_p
    # = Inv0, Inv1, Het, NA
    Inv0_p = []
    Inv1_p = []
    Het_p = []
    NA_num = 0
    Inv0 = 0
    Het = 0
    Inv1 = 0
    k = len(signifDSlist)
    temp_sample_list = []
    for x in range (0, (k)):#for all x in the number of diagnostic SNPs
        if significant_VCF_list[x][sample] == signifDSlist[x][7]:#Inv0
            Inv0 += 1#add 1 to the inv 0 counter if the nucleotide matches the nucleotide from the INV0 column in the DS list
            if float(signifDSlist[x][6]) < 0.0:#account for negatives
                temp = (1.0 + float(signifDSlist[x][6]))
            else:
                temp = (1.0 - float(signifDSlist[x][6]))#add 1-the diagnostic certainty to a temporary object
            Inv0_p.append(temp)#make a list of 1-P for all inv0 values
        elif significant_VCF_list[x][sample] == signifDSlist[x][8]:#Inv1 same logic as above
            Inv1 += 1
            if float(signifDSlist[x][6]) < 0.0:
                temp = (1.0 + float(signifDSlist[x][6]))
            else:
                temp = (1.0 - float(signifDSlist[x][6]))
            Inv1_p.append(temp)
        elif significant_VCF_list[x][sample] == "HET":#Het same logic as above
            Het += 1
            if float(signifDSlist[x][6]) < 0.0:
                temp = (1.0 + float(signifDSlist[x][6]))
            else:
                temp = (1.0 - float(signifDSlist[x][6]))
            Het_p.append(temp)
        else:#count all the NA sites. Non matching sites have been removed, but some samples may have SNP calling errors we'll want to keep track of.
            NA_num += 1
    counts = (Het + Inv0 + Inv1)
    #print "\nSANITY:\n", Het_p, "\n", Inv0_p, "\n", Inv1_p#make sure the probability counter is working
    hetp = 1.0
    inv0p = 1.0
    inv1p = 1.0
    if len(Het_p) > 0:#change the value of this temporary object from 1 to the product of probability if there are hits
        hetp = product(Het_p)
    if len(Inv0_p) > 0:
        inv0p = product(Inv0_p)
    if len(Inv1_p) > 0:
        inv1p = product(Inv1_p)
    if counts > 0:
        Het_final = (1.0 - (hetp))*(1.0*Het/counts)*100#calculate the probability for each halpotype
        Inv0_final = (1.0 - (inv0p))*(1.0*Inv0/counts)*100
        Inv1_final = (1.0 - (inv1p))*(1.0*Inv1/counts)*100
    else:#IF THERE ARE NO COUNTS AT ALL LEAVE THE FINAL VALUES EMPTY
        Het_final = ""
        Inv0_final = ""
        Inv1_final = ""
    i = (sample-9)
    total = (counts + NA_num)
    max_likely = ""#pull out the haplotype with the highest probability as the most likely haplotype:
    if Het_final > Inv0_final and Het_final > Inv1_final:
        max_likely = "HET"
    elif Inv0_final > Het_final and Inv0_final > Inv1_final:
        max_likely = "INV0"
    elif Inv1_final > Het_final and Inv1_final > Inv0_final:
        max_likely = "INV1"
    else:
        max_likely = "NO CLEAR HAPLOTYPE"#if two or more of the probabilities are perfectly equal they are either greater than 0 and no haplotype can be determined, or no SNPS were identified and they all equal 0. Either way, you can't determine a haplotype. 
    temp_sample_list = [headers[i],Inv0,Inv0_final,Inv1,Inv1_final,Het,Het_final,NA_num,total,max_likely]#append objects into the list in the order they appear in the output header list.
    return temp_sample_list


###Section5.5: Actually write the output file by looping the haplotyping function:###

#Write an output file
output = open(Output_file_name, 'w')
for j in range(0,(len(output_headers))):#for all headers in the file,
    if j < (len(output_headers)-1):
        output.write(output_headers[j])#write each header separated by a tab
        output.write("\t")
    else:#except for the last header, end line with \n
        output.write(output_headers[j])
        output.write("\n")
for x in range(9,(len(headers)+9)):#for all columns of the significant VCF matrix starting with column 9
    templine = haplotype_sample(signifDSlist,significant_VCF_list,x)#set the line equal to the output of the haplotyping function for column x
    q = (len(templine)-1)
    f = 0
    while f < len(templine):#for all samples,
        w = str(templine[f])
        if f < q:
            output.write(w)#write each index of the temp line separated by \t
            output.write("\t")
            f += 1
        else:
            output.write(w)
            output.write("\n")#end the line with \n
            f += 1
output.close()